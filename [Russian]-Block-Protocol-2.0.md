Одним из наиболее критикуемых моментов в Эфириум и Биткойн-подобных протоколах в целом является масштабируемость. При том, что разработчики ядра Биткойн, равно как и разработчики других проектов (в частности, Ripple) произвели ряд точечных улучшений способа хранения блокчейна — например, отделили состояние ("ledger" or "UTXO set") от списка транзакций, а также , не было сделано главное — каждая полная нода всё ещё обязана проводить каждую транзакцию (что приводит к). На данный момент Эфириум тоже не решает эту проблему.

Ниже описан протокол хранения и добычи блоков, а особенно  the stack trace mechanism.

### Процесс майнинга

![](https://camo.githubusercontent.com/fdaa80d3b543217d5ad302654e759a23aa232251/68747470733a2f2f7777772e657468657265756d2e6f72672f67685f77696b692f35303070782d4d696e65726368617274332e706e67)

При майнинге майнер на самом деле постоянно проходит следующую процедуру:

1. Берёт на входе

* `uncle_headers` — 
* `timestamp` — текущее время
* `parent` — родительский (предыдущий) блок
* `extra_data` — 
* `coinbase` — 
* `txlist` — пачка транзакций, которая и войдёт в этот блок

2. Автоматически присваивает переменным значения:

* `difficulty = adjust_difficulty(parent.difficulty,timestamp,parent.timestamp)`
* `reward = 15 * 10^18` (цифра приведена для примера, точный размер вознаграждения ещё будет продумываться)
* `block_header = [ parent.hash, parent.number + 1, TRIEHASH(txlist), TRIEHASH(uncle_headers), 0, coinbase, 0, difficulty, timestamp, extra_data, 0 ]`

3. 


### Алгоритм валидации блока

![](https://camo.githubusercontent.com/09d5275b9a521d9714c93cbd5cd5a27d800d5e9a/68747470733a2f2f7777772e657468657265756d2e6f72672f67685f77696b692f35303070782d4d696e65726368617274322e706e67)

1. Взять на входе: 

* `block` — заголовок блока
* `uncle_list` — список дядь заголовка
*
*
* `now` — текущее время (с точки зрения процессора майнера)

2. Проверить следующее:

*
*
*
*
*
*

3.

4.

5.

6. Проверить, что `txstack.root == ''`

7. Проверить, что `state.root == block.state_root`

8. Если хотя бы какая-либо из проверок не прошла успешно, return FALSE. В противном случае return TRUE.

Если блок валиден, необходимо определить TD (total difficulty = полная сложность) для нового блока. Она определяется рекурсивно: начальное условие имеет вид `TD(genesis_block) = 0`, при переходе к следующему блоку изменяется по закону `TD(B) = TD(B.parent) + sum([u.difficulty for u in B.uncles]) + B.difficulty`. Задать 

### Экономика

У описанного выше протокола есть один недостаток: он уязвим к атакам вида "отказ в обслуживании".  