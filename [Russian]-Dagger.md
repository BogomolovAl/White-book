
В данный момент есть три категории требовательных к памяти алгоритмов майнинга: scrypt; алгоритм, встречающийся в Праймкойн; и birthday problem.

Dagger — proof-of-work алгоритм, который должен решить эти проблемы. Это требовательный к оперативной памяти алгоритм, основанный на связных направленных ацикличных графах (directed acyclic graphs => DAG, отсюда и название), который, при всей неидеальности, обладает гораздо более ...  свойствами, чем все популярные сейчас proof-of-work алгоритмы.

## Почему алгоритм должен предъявлять сумасшедшие требования к оперативной памяти?

Главным образом, для того, чтобы майнинг не мог производиться на специально изготовленном оборудовании. Для Биткойна (алгоритм SHA-256) более года производятся специализированные устройства, называемые АСИКами (application-specific integrated circuits), единственным предназначением которых является вычисление миллиардов SHA-256 хэшей в попытке "найти" новый блок Биткойн-блокчейна. Никаких других приложений у этих устройств, кроме майнинга биткойнов, и, видимо, перебора паролей, нет. Эти устройства в тысячи раз более эффективны, чем обычные процессоры (CPU) и видеокарты (GPU), что приводит к тому, что простые владельцы ПК, не купившие АСИК, выбывают из гонки. (Прибавим к этому проблемы с тем, что производят их в основном в США, и до РФ он доедет тогда, когда выйдет уже следующее поколение; проблемы с таможней..)

Эта тенденция к доминированию спецоборудования приводит сразу к нескольким вредным эффектам:

1. **Она убивает аспект демократического распределения криптовалюты.**  В случае наличия у отдельных лиц специализированного (и, по определению, намного более мощного оборудования), никакого равномерного распределения денег не происходит

2. **Она увеличивает количество впустую потраченного электричества.**

3. **Она централизует майнинг в руках небольшого количества лиц**, производящих АСИКи. Это многократно увеличивает вероятность атаки 51% и потенциально делает сеть лёгкой добычей для правительственных регуляторов, ведь имена производителей АСИКов общеизвестны.


## Почему алгоритм не должен предъявлять сумасшедшие требования к оперативной памяти?

1. **Теоретически, для каждого алгоритма можно изготовить АСИК.** Это соображение стало особенно популярно, когда появились новости о скором выходе scrypt-АСИКов

2. Если алгоритм будет предъявлять такие требования к оперативной памяти, что майнить его будет возможно только на CPU (казалось бы, то, чего мы хотим), то практически все вычислительные мощности будут в руках у владельцев **майнинг-ботнетов**. 




## Существующие альтернативы

Каждый новый алгоритм, новая криптографическая реализация, как противопоставляющие себя прекрасно протестированным существующим, должны быть серьёзно обоснованы. В такой тонкой области, как криптовалюты, осторожность особенно важна, т.к. в систему вложены миллионы долларов капитала частных лиц. Цель данного раздела — пройтись по трём существующим альтернативам и показать, почему они являются неподходящими для наших целей.

### Scrypt

Scrypt — это алгоритм, используемый в [Лайткойн](https://litecoin.org/ru/), [Догекойн](http://dogecoin.com/) и большинстве выходящих сейчас (в июне 2014) криптовалют. Scrypt-подобные алгоритмы работают примерно так:

### Праймкойн 

Алгоритм [Праймкойна](http://primecoin.io/) не задействует оперативную память в большой степени. Майнинг заключается в поиске так называемых цепочек Куннингема — цепочек вида `[ n+1, 2n+1, 4n+1 ..., n*2^k+1 ]` для достаточно больших `k`. Оказывается, что длинную цепочку крайне сложно обнаружить без предварительной конструкции "решето". Преимущество Праймкойна — в том, что верификация происходит практически мгновенно и не предъявляет особых требований к оперативной памяти; всё, что нужно для верификации — запустить тест Ферма для проверки того, что все числа простые. Однако у алгоритма Праймкойна есть две слабости:

1. '''Time-memory tradeoff''' — 

2. '''All clear effect''' — 

## Описание алгоритма

Алгоритм Dagger создаёт направленный ацикличный граф (это термин, обозначающий дерево, где каждая вершина может иметь сколько угодно родителей) с 2<sup>23</sup> - 1 последовательных узлов. Каждый узел зависит от 3-15 случайно выбранных узлов перед ним. Если майнер находит узел, номер которого между 2<sup>22</sup> и 2<sup>23</sup>, а хэш меньше (2<sup>256</sup> делить на сложность), proof-of-work валидна.

Пусть `D` — первичная информация (заголовок блока в случае Биткойна), `N` — nonce, `||` — оператор конкатенации (пример: `'foo' || 'bar' == 'foobar'`). Вот полный код алгоритма Dagger:

```
D(data,xn,0) = sha3(data)
D(data,xn,n) =
    with v = sha3(data + xn + n)
         L = 2 if n < 2^21 else 11 if n < 2^22 else 3
         a[k] = floor(v/n^k) mod n for 0 <= k < 2
         a[k] = floor(v/n^k) mod 2^22 for 2 <= k < L
    sha3(v ++ D(data,xn,a[0]) ++ D(data,xn,a[1]) ++ ... ++ D(data,xn,a[L-1]))
```

## Свойства

Цель: найти `xn`, `n`, такие, что `n > 2^22` и `D(data,xn,n) &lt; 2^256 / diff`.

1.

2. Одной из потенциальных проблем являются так называемые "ленивые вычисления"; части деревьев могут вычисляться только при необходимости (для уменьшения количества необходимых к вычислению хэшей). 

3.

4. Для верификации необходимо перебрать 3000 - 25000 хэшей.

5.


## Заключение 

Свойства алгоритма Dagger не идеальны, но это всё равно сильно улучшение по сравнению с теми proof-of-work алгоритмами, которые встречались в криптовалютах раньше. 