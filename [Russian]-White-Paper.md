[Russian] White Paper — Манифест проекта Эфириум. [Ссылка на англоязычный оригинал.](https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-White-Paper)

### Зачем мне это нужно?

У всех сервисов, которыми вы пользуетесь в повседневности, есть нечто общее: они централизованы. Когда вы размещаете деньги в банке, вам приходится доверять ему — доверять его честности, защищённости от хакеров и государственного давления; верить в соблюдение им банковской тайны, верить в то, что проверка его деятельности проводится независимыми аудиторами. (Наконец, верить в беспристрастность судов в вашей местности, если по каким-то причинам так вышло, что вы судитесь с банком.) Абсолютно та же история и с размещением в Фейсбуке фотографий, и с важным документом, выложенным на Dropbox. Эта модель ущербна, но до недавних пор децентрализованных альтернатив не существовало.

А теперь есть [Эфириум](https://ethereum.org/).

Приложения, построенные поверх Эфириум, не требуют от пользователя доверять вообще никому, а исходный код самого Эфириума открыт и может быть проанализирован каждым. Эфириум не только решает описанные выше проблемы, он также открывает дверь для всех типов децентрализованных приложений, в том числе тех, которые мы ранее не могли даже помыслить.

### Обозначения

Биткойн в значении "сеть, система" мы будем писать с большой буквы. В значении валюты мы будем писать с маленькой — "переслал 1 биткойн", "переслал 2.71828 биткойнов". (Как Земля и земля.)

BTC — стандартное (на данный момент) обозначение для валюты биткойн.

Слова "узел", "нод" и "нода" (от англ. *"node"* - узел) в этом тексте обозначают абсолютно одно и то же. 

### Платформа следующего поколения для смарт-контрактов и децентрализованных приложений

Когда [Сатоши Накамото](http://ru.bitcoinwiki.org/%D0%A1%D0%B0%D1%82%D0%BE%D1%88%D0%B8_%D0%9D%D0%B0%D0%BA%D0%B0%D0%BC%D0%BE%D1%82%D0%BE) запустил блокчейн [Биткойна](http://bitnovosti.com/chto-takoe-bitcoin/) в январе 2009-го, на самом деле он одновременно запустил также две радикальные и совершенно не тестировавшиеся до того момента концепции. Первая — это "биткойн", [одноранговая](http://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%BD%D0%BE%D1%80%D0%B0%D0%BD%D0%B3%D0%BE%D0%B2%D0%B0%D1%8F_%D1%81%D0%B5%D1%82%D1%8C) децентрализованная криптовалюта без так называемой [внутренней стоимости](http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/) или центрального эмитента. В качестве валюты Биткойн привлекал и привлекает некоторое внимание публики — как в политическом аспекте как валюта без центрального банка, так и как валюта с большой [волатильностью](http://ru.wikipedia.org/wiki/%D0%92%D0%BE%D0%BB%D0%B0%D1%82%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C). Однако также есть другая, не менее важная, часть эксперимента Сатоши: концепция блокчейна, основанная на [proof-of-work](http://ru.wikipedia.org/wiki/Proof-of-work), который используется как инструмент публичной договорённости о порядке транзакций. В Биткойн работает правило "кто первый встал, того и тапки": если пользователь имеет 50 BTC, и одновременно пересылает 50 BTC пользователям A и B, то только транзакция, подтверждённая первой, пройдёт. Нет никакого способа узнать, какая из двух транзакций была произведена раньше, и именно это десятилетиями ставило в тупик развитие децентрализованных цифровых валют. Блокчейн Сатоши был первым заслуживающим доверия децентрализованным решением. Сейчас внимание сообщества переключается на эту другую часть биткойн-технологии — на то, каким образом идея блокчейна может быть использована для чего-то помимо денег.

В этом контексте обычно говорят о блокчейн-цифровых активах, представляющих некоторые валюты и финансовые инструменты (["цветные монеты"](https://docs.google.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit)), блокчейн-подтверждениях владения каким-либо устройством (["умная собственность"](http://bitnovosti.com/2014/06/10/ponyatie-umnoi-sobstvennosti/)), не заменяемых активах, таких как доменные имена (["Неймкойн"](http://ru.bitcoinwiki.org/Namecoin)), а также более продвинутых приложениях, таких как децентрализованные биржи, финансовые деривативы, пиринговые азартные игры и интегрированные в блокчейн системы идентификации (что-то вроде никнеймов) и репутации. Другая интересная важная область — "смарт-контракты" — представляющие собой программный код контракты, которые автоматически производят криптовалютные переводы и переводы других цифровых активов в соответствии с тем, что прописал автор контракта. К примеру, контракт может иметь форму "A может забрать вплоть до X единиц валюты в день, B — до Y единиц валюты в день, A и B по договорённости могут забрать всё, и A может отключить возможность B забирать валюту"; поскольку Эфириум предлагает Тьюринг-полный язык для написания таких контрактов, действие контракта натурально ограничено только фантазией автора (и количеством вычислительных операций, конечно — чтобы особо весёлые авторы не вешали сеть). Логичным расширением этой идеи являются [децентрализованные автономные организации](http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/) (ДАО) — смарт-контракты на большой срок, хранящие активы и определяющие правила работы целой организации. Идея Эфириума — предоставить блокчейн со встроенным полностью самостоятельным Тьюринг-полным языком программирования, который может быть использован для создания любых мыслимых "контрактов", позволяя пользователям создавать любую из описанных выше систем,— равно как и такие, которые человечество ещё не смогло вообразить — просто записывая логику работы такой системы в несколько строчек кода.

### Оглавление

* [Введение в биткойн и существующие концепции](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%B1%D0%B8%D1%82%D0%BA%D0%BE%D0%B9%D0%BD-%D0%B8-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%89%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%86%D0%B8%D0%B8)
  - [История](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%98%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F)
  - [Биткойн как система изменения состояний](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%91%D0%B8%D1%82%D0%BA%D0%BE%D0%B9%D0%BD-%D0%BA%D0%B0%D0%BA-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B9)
  - [Майнинг](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%9C%D0%B0%D0%B9%D0%BD%D0%B8%D0%BD%D0%B3)
  - [Деревья Мёркла](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F-%D0%9C%D1%91%D1%80%D0%BA%D0%BB%D0%B0)
  - [Альтернативные приложения блокчейна](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%90%D0%BB%D1%8C%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD%D0%B0)
  - [Написание сценариев (скриптов)](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%9D%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D1%86%D0%B5%D0%BD%D0%B0%D1%80%D0%B8%D0%B5%D0%B2-%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B2)
* [Эфириум](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%AD%D1%84%D0%B8%D1%80%D0%B8%D1%83%D0%BC)
  - [Эфириум-аккаунты](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%AD%D1%84%D0%B8%D1%80%D0%B8%D1%83%D0%BC-%D0%B0%D0%BA%D0%BA%D0%B0%D1%83%D0%BD%D1%82%D1%8B)
  - [Сообщения и транзакции](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%A1%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B8)
  - [Функция изменения состояния в Эфириум](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F-%D0%B2-%D0%AD%D1%84%D0%B8%D1%80%D0%B8%D1%83%D0%BC)
  - [Выполнение кода](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%92%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%B4%D0%B0)
  - [Блокчейн и майнинг](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%91%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD-%D0%B8-%D0%BC%D0%B0%D0%B9%D0%BD%D0%B8%D0%BD%D0%B3)
* [Приложения](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)
  - [Система жетонов](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%B6%D0%B5%D1%82%D0%BE%D0%BD%D0%BE%D0%B2)
  - [Финансовые деривативы и валюты](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%A4%D0%B8%D0%BD%D0%B0%D0%BD%D1%81%D0%BE%D0%B2%D1%8B%D0%B5-%D0%B4%D0%B5%D1%80%D0%B8%D0%B2%D0%B0%D1%82%D0%B8%D0%B2%D1%8B-%D0%B8-%D0%B2%D0%B0%D0%BB%D1%8E%D1%82%D1%8B)
  - [Системы идентификации и репутации](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B-%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B8-%D0%B8-%D1%80%D0%B5%D0%BF%D1%83%D1%82%D0%B0%D1%86%D0%B8%D0%B8)
  - [Децентрализованное хранение файлов](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%94%D0%B5%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5-%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2)
  - [Децентрализованные автономные организации](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%94%D0%B5%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B0%D0%B2%D1%82%D0%BE%D0%BD%D0%BE%D0%BC%D0%BD%D1%8B%D0%B5-%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)
  - [Дальнейшие приложения](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%94%D0%B0%D0%BB%D1%8C%D0%BD%D0%B5%D0%B9%D1%88%D0%B8%D0%B5-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)
* [Размышления и разное](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%A0%D0%B0%D0%B7%D0%BC%D1%8B%D1%88%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%80%D0%B0%D0%B7%D0%BD%D0%BE%D0%B5)
  - [Реализация modified GHOST](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-modified-ghost)
  - [Комиссии](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%9A%D0%BE%D0%BC%D0%B8%D1%81%D1%81%D0%B8%D0%B8)
  - [Вычисление и Тьюринг-полнота](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8-%D0%A2%D1%8C%D1%8E%D1%80%D0%B8%D0%BD%D0%B3-%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D1%82%D0%B0)
  - [Валюта и выпуск](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%92%D0%B0%D0%BB%D1%8E%D1%82%D0%B0-%D0%B8-%D0%B2%D1%8B%D0%BF%D1%83%D1%81%D0%BA)
  - [Централизация майнинга](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%A6%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BC%D0%B0%D0%B9%D0%BD%D0%B8%D0%BD%D0%B3%D0%B0)
  - [Масштабируемость](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%9C%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D1%8C)
* [Заключение](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%97%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5)
* [Заметки и дальнейшее чтение](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%97%D0%B0%D0%BC%D0%B5%D1%82%D0%BA%D0%B8-%D0%B8-%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%B5%D0%B9%D1%88%D0%B5%D0%B5-%D1%87%D1%82%D0%B5%D0%BD%D0%B8%D0%B5)

## Введение в биткойн и существующие концепции
### История

Концепция децентрализованной цифровой валюты, а также альтернативных приложений, таких как реестры собственности, витала в воздухе десятилетиями. Протоколы "электронного кэша" 80-х и 90-х, по большей части опиравшиеся на широко известное в криптографии понятие [слепой подписи](http://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%B5%D0%BF%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D1%8C), предлагали валюту высокой степени анонимности, но не получили никакого распространения, поскольку принципиально зависели от централизованного посредника. Представленная в 1998 Вэй Даем (Wei Dai) концепция [b-money](http://www.weidai.com/bmoney.txt) стала первой, в которой говорилось как про идею децентрализованного соглашения между участниками, так и про идею создания денег посредством решения вычислительных задач. Однако его предложение было скудным на детали того, как конкретно можно было бы реализовать это децентрализованное соглашение. В 2005 Хал Финни ([Hal Finney](http://en.wikipedia.org/wiki/Hal_Finney_(cypherpunk))) предложил криптовалюту с концепцией "reusable proofs of work", которая использует идеи b-money вместе с вычислительно сложными Hashcash puzzles Адама Бэка ([Adam Back](http://en.wikipedia.org/wiki/Adam_Back)) — к сожалению, его идея также включала в себя посредника, которому пользователи должны были доверять. 

Поскольку речь идёт о валюте, и порядок проведения транзакций часто критически важен, в децентрализованной валюте должно быть реализовано децентрализованное соглашение между участниками. Главная преграда, с которой сталкивались все протоколы валют до Биткойна is the fact that, while there had been plenty of research on creating secure Byzantine-fault-tolerant multiparty consensus systems for many years, all of the protocols described were solving only half of the problem. The protocols assumed that all participants in the system were known, and produced security margins of the form "if N parties participate, then the system can tolerate up to N/4 malicious actors". The problem is, however, that in an anonymous setting such security margins are vulnerable to sybil attacks, where a single attacker creates thousands of simulated nodes on a server or botnet and uses these nodes to unilaterally secure a majority share.

Инновация, внедрённая Сатоши, заключалась в том, что он скомбинировал протокол децентрализованного соглашения (очень простой, основанный на узлах, объединяющих транзакции в "блоки" каждые 10 минут), и концепцию [proof-of-work](http://ru.wikipedia.org/wiki/Proof-of-work), с помощью это вычислительно сложно и перерисовывать историю транзакций как вздумается не получится. Влияние каждого узла в Биткойн пропорционально его вычислительной мощности; организовать вычислительную мощность больше, чем мощность всей сети, многократно сложнее, чем просто симулировать миллион узлов. Несмотря на грубую простоту блокчейна Биткойн, он доказал свою работоспособность, и стал колыбелью более чем 200 криптовалют, выпущенных на основе его кода за 5 лет работы системы.

### Биткойн как система изменения состояний

![](https://camo.githubusercontent.com/e7a1fc59abdd42654fa8c54c0f847eb2c8fda72e/687474703a2f2f766974616c696b2e63612f66696c65732f73746174657472616e736974696f6e2e706e673f32)

С технической точки зрения, бухгалтерская книга Биткойна — система изменения состояний. "Состояние" здесь — это владение некоторым числом биткойнов, а "функция изменения состояния" — функция, по состоянию и транзакции возвращающая новое состояние. В стандартной банковской системе, для примера, состояние — это выписка о балансе, транзакция — это запрос о переводе $X от A к B, и функция изменения состояния уменьшает значение на счёте A на $X и увеличивает значение на счёте B на $X. Если на счёте A меньшая сумма, чем $X, функция изменения состояния возвращает ошибку. Формально это выглядит так:

```
APPLY(S,TX) -> S' or ERROR
```

В банковской системе, описанной выше

```
APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30, Bob: $70 }
```

Но:

```
APPLY({ Alice: $50, Bob: $50 },"send $70 from Alice to Bob") = ERROR
```

"Состояние" какого-то адреса в системе Биткойн — это количество BTC на нём (технически, "непотраченные результаты входящих транзакций", НРВТ), при этом каждому НРВТ соответствует количество денег и владелец (адресат). Владелец — это просто номер кошелька, 20-байтовый адрес, называемый *публичным ключом*<sup>[1](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%97%D0%B0%D0%BC%D0%B5%D1%82%D0%BA%D0%B8)</sup> (*я насчитал 34 байта, WTF?*). У каждой транзакции есть один или больше входов — при этом каждый вход содержит отсылку к соответствующему ему НРВТ и криптографическую подпись, сделанную приватным ключом владельца; выходов тоже может быть один или несколько, и каждый выход содержит новую НРВТ.  

Принцип работы функции изменения состояния `APPLY(S,TX) -> S'` выглядит примерно так:

1. Для каждого входа в `TX`:
   - Если ему соответствует НРВТ, находящееся не в `S`, вернуть ошибку.
   - Если предоставленная криптографическая подпись не совпадает с подписью владельца НРВТ, вернуть ошибку.
2. Если сумма всех денег на входе меньше, чем сумма всех денег на выходе, вернуть ошибку.
3. Вернуть `S`, у которого "ушедшие в транзакцию" (отправленные на вход транзакции) НРВТ, удалены, и к которому добавлены все НРВТ, полученные "на выходе" из транзакции.

Первая часть первого пункта не позволяет отправителям тратить монеты, которыми они не обладают; вторая часть не позволяет тратить монеты других людей. Второй пункт нужен понятно зачем. Напоследок разберём простенький пример. Пусть Алиса хочет переслать 11.7 BTC Бобу. Для этого сначала Алиса должна найти набор НРВТ, обладание которыми она может подтвердить и сумма средств которых равна как минимум 11.7 BTC. В большинстве ситуаций Алисе не удастся найти у себя несколько НРВТ, сумма средств на которых в точности бы равнялась 11.7 BTC; вместо этого ей, например, пересылали 6, 4 и 2 BTC, и наименьшее число, которое она может собрать из имеющихся у неё НРВТ равно 6+4+2=12. Затем она создаёт транзакцию с тремя входами и двумя выходами. Первым выходом будет адрес Боба, куда отправится 11.7 BTC, вторым — один из кошельков Алисы, куда отправится 0.3 BTC "сдачи".


### Майнинг

![](https://camo.githubusercontent.com/e8e2a0c15c17b066e7f17056f7697819b9a1aa33/687474703a2f2f766974616c696b2e63612f66696c65732f626c6f636b5f706963747572652e706e67)

Если бы речь шла о централизованном сервисе, которому пользователи должны доверять (PayPal, WebMoney), всё было бы просто: транзакции проходят через центральные сервера и их история хранится на них же. Однако, поскольку мы разрабатываем децентрализованную валюту, необходимо скомбинировать систему проведения транзакций с системой децентрализованного соглашения, чтобы соглашение о порядке транзакций у каждого пользователя сети было одно и то же. В системе Биткойн это достигается путём объединения транзакций в "блоки". Протокол Биткойн-сети устроен так, что производит примерно один блок в десять минут; каждый блок содержит точное время создания, значение nonce (сокращение от number used once), хэш предыдущего блока (чтобы была связь с ним) и список всех транзакций, которые в него попали (обычно это все транзакции, произошедшие с начала майнинга предыдущего блока). Так и возникает блокчейн (*букв. перев.* "цепочка блоков"). Никаких изменений в блокчейне не происходит, он лишь постоянно растёт; блокчейн хранит в себе историю всех транзакций и совершенно децентрализован.

Алгоритм проверки валидности блока в этой системе таков:

1. Проверить, существует ли и валиден ли предыдущий блок.
2. Проверить, что таймштамп рассматриваемого блока больше, чем таймштамп предыдущего<sup>[2](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%97%D0%B0%D0%BC%D0%B5%D1%82%D0%BA%D0%B8)</sup> (принцип причинности), но не более, чем на 2 часа.
3. Проверить proof-of-work рассматриваемого блока.
4. Пусть `S[0]` — состояние в конце предыдущего блока.
5. Пусть `TX` — список транзакций блока, а всего этих транзакций `n`. Для всех `i` из набора `0..n-1`, зададим `S[i+1] = APPLY(S[i],TX[i])`. Если любая такая apply-процедура выдаёт ошибку, выйти из цикла и выдать ошибку.
6. Код выполнен успешно, и `S[n]` — состояние после обсчёта транзакций этого блока.

Заметим, что состояние (счёта) не включено в блок ни в коей мере; узлы, занимающиеся валидацией, вычисляют его (для проверки того, что деньги у пациента вообще есть), проходя весь путь по блокчейну с самого начала. Порядок, в котором майнер включает транзакции в блок, имеет значение: если в данном блоке есть две транзакции A→B и B→C, такие, что B тратит средства (НРВТ), предоставленные A, то угадайте, дети, в каком порядке эти транзакции должны идти, чтобы всё получилось?..

Нетривиальная часть валидации блока — так называемая концепция "proof-of-work": условие того, что SHA256-хэш каждого блока как 256-битное число должно быть меньше динамически изменяющейся величины, равной на момент написания этих строк примерно 2<sup>192</sup>. Эта динамически изменяющаяся величина явно вычисляется по так называемой "сложности"; сложность перенастраивается каждые 2016 блоков так, чтобы, какой бы суммарная вычислительная мощность сети ни была, в среднем каждый новый блок обнаруживался примерно раз в 10 минут. Сделано всё это для того, чтобы сделать нахождение блоков вычислительно сложным (сетью признаётся самый длинный вариант блокчейна; если находить блоки было бы легко, каждый участник с достаточно большой вычислительной мощностью мог бы перерисовать блокчейн с начала как хочет *(хотя этот аргумент мне и кажется надуманным)*). Поскольку SHA-256 — это алгоритм шифрования совершенно непредсказуемой псевдослучайной функцией (используемый при шифровании банками(?)), единственный способ найти блок — простой перебор значений nonce, т.е. простой перебор вычисляющихся по ним (а также по ) хэшей. Для подбора хэша, который как число меньше, чем 2<sup>192</sup>, нужно потратить, в среднем, 2<sup>64</sup> попытки. Нашедшему блок майнеру выплачивается вознаграждение, в данный момент равное 25 BTC. Дополнительно, если сумма на входе больше, чем сумма на выходе (отправитель установил "комиссию"), майнер, нашедший блок, соответствующий этой транзакции, забирает её себе. Это единственный способ выпуска биткойнов.

Для лучшего понимания майнинга обсудим, что произойдёт при попытке атаки. Поскольку криптография, лежащая в основе Биткойн (SHA-256 алгоритм), на данный момент является защищённой (в частности, активно используется банками(?)), целью злоумышленника будет часть системы, напрямую не связанная с шифрованием — порядок транзакций. 

Стратегия предполагаемого злоумышленника могла бы быть такой:

1. Переслать продавцу 100 BTC за некоторый продукт (лучше всего, цифровой продукт быстрого получения).
2. Дождаться получения продукта.
3. Произвести другую транзакцию, переслав 100 BTC на другой свой адрес.
4. Попытаться убедить систему, что транзакция самому себе была произведена первой.

Как только произошёл шаг (1), спустя несколько минут некоторый майнер включит эту транзакцию в блок — например, блок 270000. Примерно за час ещё пять блоков будут добавлены в блокчейн, и каждый из новых блоков будет косвенно указывать на транзакцию (1), таким образом подтверждая её. В этот момент продавец решит, что оплата завершена, и перешлёт продукт; поскольку мы рассматриваем случай цифрового продукта, доставка моментальна. Далее злоумышленник создаёт другую транзакцию, пересылая 100 BTC себе. Если злоумышленник будет производить её как обычно, транзакция не произойдёт; майнеры, пытаясь провести эту транзакцию, запустят `APPLY(S,TX)` и заметят, что `TX` (транзакция) пытается потратить НРВТ, которого уже нет. Вместо этого злоумышленник мог бы создать форк блокчейна, начинать майнить другую версию блока 270000, отмечающую как предыдущий блок 269999, но с новой (когда он пересылает 100 BTC себе) транзакцией вместо предыдущей. Поскольку информация в этом блоке другая, ему придётся переделать proof-of-work. Более того, новая версия блока 270000 имеет другой хэш, и блоки 270001-270005 отсылают не к ней; таким образом, блокчейн всей сети и блокчейн злоумышленника совершенно различны. Правило, имплементированное в биткойн-протокол, таково: форк с самым длинным блокчейном считается истинным, и "честные" майнеры будут работать с блокчейном длиной 270005, а злоумышленник будет в одиночку работать над своим. Злоумышленник имеет шанс сделать свой блокчейн самым длинным, только если его вычислительные мощности больше суммарной вычислительной мощности всей остальной сети (так называемая "атака 51%").

### Деревья Мёркла

![](https://camo.githubusercontent.com/52e0d1b4436e61cca69cd3e3e62dda7b9bcb3b54/68747470733a2f2f7777772e657468657265756d2e6f72672f67685f77696b692f7370765f626974636f696e2e706e67)

*Слева: лишь малое число нодов в дереве Мёркла необходимо для доказательства валидности ветви.*

*Справа: любая попытка изменить любую часть дерева Мёркла приведёт к несогласованности в цепочке.*

Важным с точки зрения масштабируемости свойством Биткойна является то, что блок размещается в многоуровневой структуре информации. Хэш блока — это на самом деле хэш заголовка блока, ~200-байтовый кусок информации, включающий в себя таймштамп, nonce блока, хэш предыдущего блока и хэш корня структуры под названием дерево Мёркла, которое и хранит всю информацию о транзакциях в этом блоке. Дерево Мёркла — бинарное дерево, состоящее 1) из узлов с большим количеством листьев внизу, которые и содержат всю информацию 2) из узлов "в середине", каждый из которых является хэшем двух своих детей 3) из "корня дерева" (самого верхнего хэша), также являющегося хэшем двух своих детей. Смысл дерева Мёркла — сделать так, чтобы информация в блоке хранилась по частям: нод может загрузить только заголовок блока из некоторого источника, а потом малую часть дерева из другого источника, и быть уверенным, что вся информация корректна. Причина, почему это работает, в том, что хэши вычисляются вверх: если злоумышленник попытается "подсунуть" фейковую транзакцию вниз дерева Мёркла, все узлы "ближе к верхушке", с которыми он связан, также изменят свои хэши, и хэш заголовка блока практически наверняка тоже изменится, что приведёт к тому, что протокол зарегистрирует его как совершенно другой блок (proof-of-work которого также будет практически наверняка не валиден (см. [раздел "Майнинг"](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%9C%D0%B0%D0%B9%D0%BD%D0%B8%D0%BD%D0%B3) о том, что хэш является валидным, если он как 256-битовое число меньше некоторого динамически подстраивающегося числа; валидный хэш очень трудно найти)).

Дерево Мёркла, как сейчас кажется, действительно необходимо для жизнеспособности системы. На апрель 2014 года полная нода Биткойн-сети (полной нодой называется нода, которая хранит и непрерывно обновляет всю копию блокчейна у себя на диске) занимает 15 Гб дискового пространства и растёт более чем на 1 Гб в месяц. На данный момент хранить полную копию блокчейна могут позволить себе владельцы ПК (но не владельцы смартфонов); в будущем, по-видимому, только бизнесы и отдельно взятые фанаты будут хранить полные ноды. Протокол "упрощённой верификации платежей" (УВП) разрешает существование также "лёгких нод", которые загружают лишь заголовок блока, проверяют proof-of-work заголовков блока, и затем загружают ветки лишь с необходимыми держателю такой ноды транзакциями. Это позволяет держателям "лёгких нод" надёжно определить статус любой Биткойн-транзакции, а также собственный текущий баланс, скачав крайне малую часть всего блокчейна.

### Альтернативные приложения блокчейна

Идея нефинансового применения блокчейн-технологии также имеет долгую историю. В 2005 году Ник Сабо ([Nick Szabo](http://en.wikipedia.org/wiki/Nick_Szabo)) изложил концепцию ["secure property titles with owner authority"](http://szabo.best.vwh.net/securetitle.html), a document describing how "new advances in replicated database technology" will allow for a blockchain-based system for storing a registry of who owns what land, creating an elaborate framework including concepts such as homesteading, adverse possession and Georgian land tax. Однако, к сожалению, никакой эффективной replicated database system на тот момент не было, и протокол не имел практического применения. С 2009, однако, с развитием системы децентрализованного соглашения Биткойн число альтернатив ему стало быстро увеличиваться (благо исходный код Биткойн-протокола открыт).

* Неймкойн ([Namecoin](http://namecoin.info/)) — созданная в 2010 децентрализованная система регистрации имён (в первую очередь, DNS-серверов). В децентрализованных протоколах Tor, Bitcoin и BitMessage единственный вид идентификации пользователей — присваивание идентификатора в виде псевдослучайного хэша вида `1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy`. При этом было бы здорово иметь аккаунты с именами (идентификаторами) наподобие "george". Проблема, очевидно, в том, что если какой-то пользователь может создать аккаунт "george", то кто-то другой также сможет зарегистрировать аккаунт с тем же именем. Единственное решение здесь — парадигма «кто раньше зарегистрировал пользователя "george", того и тапки», и ровно такое решение используется в биткойн-протоколе. Неймкойн — первый и самый успешный пример системы регистрации доменных имён с такой идеей. (Неймкойн же не только этому посвящён?)

* [Цветные монеты](https://docs.google.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit) — протокол, позволяющий людям создавать цифровые жетоны (которые, в принципе, могут играть роль и новых криптовалют) на блокчейне Биткойна. "Выпуск" этих жетонов происходит путём публичного "окрашивания" некоторой Биткойн-НРВТ (упрощая, некоторого количества имеющихся у владельца биткойнов); в результате транзакции окрашенные монеты останутся окрашенными. После окрашивания биткойны перестают быть деньгами и становятся жетонами, доказывающими владение каким-то конкретным активом.

   Цветные(=окрашенные) монеты появляются в результате того, что кто-то из пользователей решает публично покрасить какую-то часть своих биткойнов (скажем, в цвет “Audi X6″). После окрашивания биткойны перестают быть деньгами и становятся жетонами, доказывающими владение каким-то конкретным активом. В результате транзакции окрашенные монеты останутся окрашенными (что позволяет быстро и без бумажек переводить людям различные активы). Возможно создание бирж цветных монет.

   А зачем? А затем, чтобы использовать блокчейн-технологию для представления других вещей. Так, монеты на блокчейне биткойна могут использоваться, скажем, для представления акций компании, слитков золота или документов на владение домом. При помощи цветных монет кто угодно может выпустить свои акции или торговать товарами, используя инфраструктуру сети Биткойн. Это предоставляет биткойнам огромное преимущество по сравнению с обычными методами передачи активов.

   Сейчас, если вы хотите передать золото, акции компании, или документы на дом, вам потребуется осуществить сложный процесс, в который включены нотариусы, регистрации в госархивах и бумажные документы. Всё это для того, чтобы удостовериться, что переход права собственности на определённый объект точно состоялся.

   Криптографическая технология Биткойн построена по-другому. Вы точно знаете, что некоторое количество биткойнов покинули один адрес и пришли на другой. Вы можете быть уверены, что это произойдёт всего лишь за несколько минут. Если биткойны могут представлять другие активы, то права на эти активы можно переслать быстро и легко, кому угодно, из любой точки земного шара. Факт пересылки, как вы понимаете (блокчейн-технология же), совершенно публичен.

   Про статус разработки кошельков и бирж, связанных с цветными монетами, на момент начала июня 2014 написано [здесь](http://bitnovosti.com/2014/06/02/could-this-holy-bitcoin-trinity-revive-colored-coins/).

* Метакойны — их идея в том, чтобы иметь протокол, действующий поверх биткойн-сети, использующий биткойн-транзакции для хранения метакойн-транзакций, но имеющий другую функцию изменения состояния `APPLY'`. Поскольку метакойн-протокол не может защитить невалидные метакойн-транзакции от появления в биткойн-блокчейне, в протокол добавляется такое правило: если `APPLY' (S, TX)` (действие этой новой функции `APPLY'`) возвращает ошибку, применить `APPLY' (S, TX) = S`. Это даёт лёгкий механизм создания произвольного криптовалютного протокола "малой кровью", т.к. сложности майнинга и распространения децентрализованной сети "уводятся" в биткойн-часть протокола. (Почитать и про метакойны, поскольку данный абзац написан пипец как непонятно.)

Таким образом, мы видим два подхода к достижению децентрализованного соглашения: построить независимую сеть, или же построить протокол поверх сети Биткойн. Первый подход, при всей его успешности в приложениях вроде Неймкойн, трудноосуществим; для реализации каждой конкретной идеи необходимо создавать свой блокчейн, а также создать и протестировать весь необходимый код. Кроме того, 1) децентрализованных приложений со временем станет настолько много, что каждому из них создавать для своих нужд блокчейн было бы совершенно нелепо 2) есть целый класс децентрализованных приложений (в т.ч. ДАО), которые нуждаются во взаимодействии друг с другом.

Основанный на Биткойне подход, с другой стороны, имеет такой недостаток: он не наследует систему упрощённой  верификации платежей (УВП), возможную в Биткойн. SPV works for Bitcoin because it can use blockchain depth as a proxy for validity; at some point, once the ancestors of a transaction go far enough back, it is safe to say that they were legitimately part of the state. Основанные на биткойне мета-протоколы, с другой стороны, cannot force the blockchain not to include transactions that are not valid within the context of their own protocols. Следовательно, внедрение полностью защищённого УВП мета-протокола потребовало бы пробегать биткойн-блокчейн вплоть до начала для определения валидности транзакций. На данный момент все "лёгкие" имплементации основанного на Биткойне мета-протокола полагаются на "сервер, которому участники сети доверяют", при том что одна из главных причин возникновения криптовалют — избавиться от необходимости кому-либо доверять. (Весь этот абзац переделать.)

### Написание сценариев (скриптов)

Даже в отсутствие каких-либо расширений протокол Биткойна поддерживает примитивную версию "смарт-контрактов". Владение НРВТ в Биткойн можно подтверждать не только публичным ключом, но и скриптом, написанным на простом stack-based языке программирования. В последнем случае транзакция, тратящая НРВТ, должна предоставить данные, которые удовлетворят такой скрипт. Действительно, даже стандартный способ с публичным ключом встроен в Биткойн-протокол как скрипт: "на входе" этот скрипт берёт криптографическую подпись эллиптической кривой, сверяет её с транзакцией и адресом, владеющим НРВТ, и возвращает 1 в случае успеха и 0 в случае неуспеха. (Здесь несогласованность с тем, что написано [здесь](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%91%D0%B8%D1%82%D0%BA%D0%BE%D0%B9%D0%BD-%D0%BA%D0%B0%D0%BA-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B9).) Возможны более замысловатые скрипты. К примеру, возможен скрипт, согласно которому для валидации необходимо 2 из 3 приватных ключей (так называемая мультиподпись). (Это может быть полезно для корпоративных аккаунтов, аккаунтов безопасного хранения и торговли с участием эскроу (что такое эскроу? поставить гиперссылку в первом месте, где это слово встречается)). Скрипты также могут быть использованы для автоматизации выплат наград за решение важных вычислительных задач; можно даже создать скрипт, говорящий что-то вроде "эта биткойн-НРВТ Ваша, если предоставлено доказательство того, что Вы переслали столько-то [догекойнов](http://tjournal.ru/paper/dogecoin) мне" — и это уже почти децентрализованная биржа криптовалют, не правда ли?

Однако встроенный в Биткойн язык сценариев имеет ряд серьёзных ограничений:

* **Отсутствие Тьюринг-полноты** — этот язык позволяет реализовать далеко не все виды вычислений. В частности, запрещены все петли (циклы). Это сделано для того, чтобы избежать бесконечных циклов во время верификации транзакций; теоретически это преодолимое препятствие для авторов скриптов, поскольку любой цикл может быть симулирован достаточно большим количеством `if`'ов — но это, конечно, приводит к "раздутию" такого скрипта, увеличению количества строк в нём во много раз (тогда почему этим ещё не воспользовались, чтобы подвесить Биткойн-сеть?). К примеру, для того, чтобы написать с нуля альтернативу алгоритму цифровой подписи эллиптической кривой, действующему в Биткойн (SHA-256), по-видимому, придётся вручную прописать 256 повторяющихся операций умножения.

* Отсутствие возможности задавать сумму транзакции — не существует способа проводить прозрачные операции с финансами с помощью НРВТ-скрипта. Для примера рассмотрим хеджирующий контракт, в который A и B закладывают эквивалент $1000 в биткойнах, и спустя 30 дней скрипт пересылает стороне A эквивалент $1000 в биткойнах, а остальное пересылает стороне B. (Доделать.)

* **Отсутствие промежуточных состояний** — возможны только либо потраченные, либо непотраченные НРВТ. Нет никакой возможности написать контракт из нескольких стадий, который мог бы содержать в себе переход к некоторому промежуточному состоянию. Биткойн-сценарии не приспособлены для многоуровневых контрактов с опциями, децентрализованных обменников и двустадийных протоколов криптографического соглашения (необходимых для безопасности наград за решение той или иной вычислительной задачи). Сказанное означает, что НРВТ могут быть использованы только для простых моментально исполняющихся контрактов, но никак не для более замысловатых контрактов с опциями и промежуточными стадиями и состояниями. По этой причине ДАО не могут быть реализованы на этом языке, по ней же трудно внедрить мета-протоколы. Этот пункт в сочетании с предыдущим приводит также к тому, что на языке сценариев Биткойн задать предельное значение суммы, которую можно вывести с той или иной биржи, не получится.

* **Блокчейн-слепота** — НРВТ не видит информацию из блокчейна (такую, как nonce и предыдущий хэш). Это сильно ограничивает возможные приложения в азартных играх и некоторых других категориях, лишая язык сценариев естественного источника случайных чисел.

Можно выделить три подхода к разработке современных приложений поверх криптовалюты: создать новый блокчейн, использовать язык сценариев поверх Биткойн, и создать мета-протокол поверх Биткойн. Создание нового блокчейна приводит к неограниченной свободе творчества, но за это придётся заплатить временем разработки и нервами, потраченными на начальную настройку, на фикс багов. Язык сценариев Биткойн прост в использовании и стандартизации, но крайне ограничен в возможностях. Мета-протоколы также просты, но трудномасштабируемы (почему?). Разрабатывая Эфириум, мы надеемся создать наиболее общий фреймворк, включающий в себя плюсы всех трёх парадигм.

## Эфириум

Цель Эфириума — объединив и доработав концепции скриптинга, альткойнов и мета-протоколов, позволить всем желающим создавать произвольные децентрализованные приложения, обладающие одновременно свойствами масштабируемости, стандартизации, feature-полноты, лёгкости разработки и совместимости. Эфириум добивается этого построением базовой платформы: блокчейна со встроенным Тьюринг-полным языком программирования, позволяющим любому желающему писать смарт-контракты и децентрализованные приложения, где каждый сможет создавать собственные произвольные правила владения, форматы транзакций и произвольные функции изменения состояния. Реализация идеи известной криптовалюты Неймкойн (Namecoin) на этом языке занимает две строки кода, а такие протоколы, как валюты и системы репутации, можно реализовать менее чем в двадцать строк. Смарт-контракты, криптографические "коробки", содержащие значение и открывающиеся только при определённых условиях, также могут быть построены поверх платформы Эфириум, причём со значительно большей мощностью, чем та, что предложена в языке сценариев Биткойн, по причине Тьюринг-полноты языка Эфириум, его value-awareness, блокчейн-зрячести и наличии промежуточных состояний (здесь калька с недостатков, описанных в предыдущем параграфе).

### Эфириум-аккаунты

В Эфириум состояние сделано из "аккаунтов"; каждому аккаунту соответствует его 20-байтовый адрес. Функции изменения состояния — переводы валюты или информации между аккаунтами. Эфириум-аккаунт содержит четыре поля:

* **nonce** — счётчик, используемый для того, чтобы каждая транзакция произошла ровно один раз 
* текущий **баланс** аккаунта (в единицах эфира)
* **код контракта**, связанного с аккаунтом (если контракт есть)
* **хранилище** аккаунта (пустое по умолчанию)

"Эфир" — главное внутреннее "крипто-топливо" Эфириума, и используется как валюта, в которой происходят транзакции. Возможны два способа ведения аккаунтов: аккаунт, контролируемый владельцем (его приватным ключом), и аккаунт, контролируемый кодом связанного с ним контракта. Первый способ — это ровно то, что было в системе Биткойн: аккаунт, единственной опцией которого является пересылка денег (создание исходящей транзакции). При втором способе каждый раз, когда аккаунт получает входящее сообщение, активируется код контракта, разрешая ему писать в хранилище или считывать оттуда информацию, посылать другие сообщения и создавать другие контракты.

### Сообщения и транзакции

"Сообщения" в Эфириум — это нечто, напоминающее транзакции в Биткойн, но с тремя существенными отличиями. Во-первых, сообщение в Эфириум может быть создано либо внешним источником (человеком), либо контрактом, в то время как Биткойн-транзакция может быть создана только человеком. Во-вторых, с помощью сообщений Эфириум можно вести обычную переписку, то есть передавать друг другу информацию, никак не связанную с транзакциями. В-третьих, получатель Эфириум-сообщения, если это контракт-аккаунт, имеет возможность "ответить" автору на него; этим Эфириум-сообщения похожи на обычные функции.

Термин "транзакция" означает в Эфириум подписанный пакет данных, в котором находится отправленное к пересылке сообщение. Транзакции содержат получателя, электронную подпись отправителя, количество пересылаемого эфира и пересылаемую информацию, а также значения двух переменных `STARTGAS` и `GASPRICE`. Для того, чтобы предотвратить бесконечные циклы в коде, каждой транзакции устанавливается предел количества вычислительных шагов. `STARTGAS` — это именно такой предел, а `GASPRICE` — сумма, которая платится майнеру за каждый вычислительный шаг. Если при выполнении транзакции "газ заканчивается", происходит возврат к тем состояниям, которые были до начала её выполнения, с одним, правда, условием: комиссии, выплаченные майнерам за их вычисления, остаются у майнеров. Если выполнение транзакции прерывается при ненулевом количестве газа, остающееся количество пересылается обратно отправителю транзакции. There is also a separate transaction type, and corresponding message type, for creating a contract; the address of a contract is calculated based on the hash of the account nonce and transaction data.

An important consequence of the message mechanism is the "first class citizen" property of Ethereum - the idea that contracts have equivalent powers to external accounts, including the ability to send message and create other contracts. This allows contracts to simultaneously serve many different roles: for example, one might have a member of a decentralized organization (a contract) be an escrow account (another contract) between an paranoid individual employing custom quantum-proof Lamport signatures (a third contract) and a co-signing entity which itself uses an account with five keys for security (a fourth contract). The strength of the Ethereum platform is that the decentralized organization and the escrow contract do not need to care about what kind of account each party to the contract is.

### Функция изменения состояния в Эфириум

![](https://camo.githubusercontent.com/b58b83c9f2e11865c2cb282f04be899dfbad491f/687474703a2f2f766974616c696b2e63612f66696c65732f65746865727472616e736974696f6e2e706e673f31)

Эфириум-функция изменения состояния `APPLY(S,TX) -> S'` работает так:

1. Check if the transaction is well-formed (ie. has the right number of values), the signature is valid, and the nonce matches the nonce in the sender's account. Вернуть ошибку, если что-то не так.
2. Вычислить комиссию по формуле `STARTGAS * GASPRICE` и определить адрес отправителя по подписи. Вычесть величину комиссии из баланса отправителя и увеличить на единицу его nonce. Если баланс отправителя меньше значения взимаемой комиссии, вернуть ошибку.
3. Присвоить `GAS = STARTGAS`, and take off a certain quantity of gas per byte to pay for the bytes in the transaction.
4. Переслать сумму транзакции с аккаунта отправителя на аккаунт получателя. Если аккаунта получателя не существует, создать его. Если аккаунт получателя — контракт, запустить код контракта (тут, естественно, два исхода — либо контракт будет вычислен до конца, либо во время вычисления закончится газ).
5. Если по какой-то причине денежный перевод не удался (у отправителя не было суммы перевода, или при вычислении контракта закончился газ), откатить все изменения, кроме выплаты комиссий за вычисления майнеру.
6. В случае успешного выполнения контракта вернуть оставшийся газ отправителю, а весь потраченный переслать майнеру.

Рассмотрим пример. Пусть код контракта таков:

```
if !contract.storage[msg.data[0]]:
    contract.storage[msg.data[0]] = msg.data[1]
```

Заметим, что в реальности контракт пишется на низкоуровневом языке ("ВМЭ-код"); этот пример написан для ясности на Serpent, нашем высокоуровневом языке, и может быть скомпилирован до ВМЭ-кода. Предположим, что хранилище контракта пусто, и в результате транзакции пересылаются 10 единиц эфира, контракт обеспечен 2000 единицами газа (`STARTGAS = 2000`), `GASPRICE = 0.001`, и дополнительно пересылается информация `[2, 'CHARLIE']`<sup>[3](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-White-Paper#%D0%97%D0%B0%D0%BC%D0%B5%D1%82%D0%BA%D0%B8)</sup>. Для этого примера Эфириум-функция изменения состояния сработает так:

1. Check that the transaction is valid and well formed.
2. Проверить, что у отправителя есть как минимум 2000*0.001 = 2 единицы эфира. После успешной проверки вычесть 2 единицы эфира из аккаунта отправителя.
3. Присвоить переменной `GAS` значение 2000; в предположении, что транзакция занимает 170 байтов и комиссия за байт равна 5, вычтем 850; таким образом, останется 1150 единиц газа.
4. Вычесть 10 единиц эфира из аккаунта отправителя и добавить их к аккаунту контракта.
5. Запустить выполнение кода. В нашем примере это совсем просто: код проверяет, есть ли в хранилище контракта (*стоп, хранилище же является атрибутом аккаунтов?*) информация по адресу `2`, замечает, что её там нет и прописывает туда значение `CHARLIE`. Предположим, это стоит 187 единиц газа, и газа остаётся 1150 - 187 = 963.
6. Вернуть 963*0.001 = 0.963 единиц эфира отправителю. 

И это всё! Если аккаунт, на который производится пересылка, не содержит контракта, шаг с выполнением кода контракта, очевидно, надо пропустить, и всё ещё проще: комиссия будет равна попросту комиссии за байт, умноженной на количество байтов в транзакции, и никакой пересылки информации (вроде значения `CHARLIE`) происходить не будет. Дополнительно, заметим, что созданные контрактом сообщения могут, в свою очередь, указывать, каким количеством газа конкретно их подвычисление обеспечено, и если газ, выделенный такому подвычислению, закончится, откат (к предыдущему состоянию) происходит к моменту вызова сообщения в контракте, но не к моменту начала всего контракта. Таким образом, подобно транзакциям, контракты могут задавать строгие лимиты на количество шагов в каждом порождаемом собой подвычислении.

### Выполнение кода

Код контрактов Эфириум написан на низкоуровневом stack-based [bytecode](http://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B9%D1%82-%D0%BA%D0%BE%D0%B4) языке, который мы назвали "код виртуальной машины Эфириум" или "ВМЭ-код". :) Код состоит из последовательности байтов, и каждый байт представляет какую-то операцию. В общем случае, выполнение кода — это бесконечный цикл, состоящий из выполнения операции в текущей строке и последующего увеличения номера строки на 1; прерваться этот процесс может при достижении конца кода, ошибке в коде, или выполнении инструкций `STOP`/`RETURN` в коде. Операции могут обращаться к трём типам мест для хранения информации:

* **Стек**, last-in-first-out хранилище, куда можно записывать и откуда можно извлекать значения
* **Память**, байтовый массив произвольного размера
* Привязанное к контракту долговременное **хранилище** ключей и значений. В отличие от стека и памяти, которые очищаются после выполнения кода, хранилище используется для долговременного хранения параметров.

Код также имеет доступ к денежной сумме, отправителю и информации входящего сообщения, а также к информации в заголовке блока; код может вернуть в том числе байтовый массив на выходе.

Принцип выполнения нашего ВМЭ-кода на удивление прост. Выполнение происходит так: вся информация о состоянии вычисления содержится в наборе `(block_state, transaction, message, code, memory, stack, pc, gas)`, где `block_state` содержит информацию обо всех аккаунтах, включая балансы и состояния хранилищ. При каждом раунде выполнения берётся `pc`-ый байт `code` и выполняется инструкция, соответствующая этому байту (напомним, что ВМЭ-код — байткод); каждая инструкции на наш набор действует по-своему. Для примера, `ADD` достаёт два элемента из стека и возвращает туда их сумму, после чего уменьшает `gas` на 1 и увеличивает `pc` на 1; а, скажем, `SSTORE` берёт верхние два элемента стека и вставляет второй элемент в хранилище контракта по адресу, равному первому элементу (нечто похожее было проделано в предыдущем разделе с информацией `[ 2, 'CHARLIE' ]`). Хотя существует масса способов оптимизировать Эфириум посредством [динамической компиляции](http://ru.wikipedia.org/wiki/JIT-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F), простейшая реализация Эфириума занимает всего лишь пару сотен строк кода.

### Блокчейн и майнинг

![](https://camo.githubusercontent.com/8a6c1a9e3ec629cccccfc3fdabeaab67259fe414/687474703a2f2f766974616c696b2e63612f66696c65732f6170706c795f626c6f636b5f6469616772616d2e706e67)

Блокчейн Эфириума во многом похож на блокчейн Биткойна, но не во всём. :) Главное различие архитектур блокчейна в том, что, в отличие от Биткойн, блоки Эфириума содержат не только список транзакций, но и предыдущее состояние (счетов) каждого из пользователей. Помимо этого, номер блока и его сложность также размещаются в блоке. Валидация блоков в Эфириум происходит так:

1. Проверяется существование и валидность предыдущего блока.
2. Проверяются таймштампы: именно, что блок создан позже, чем предыдущий, но не более чем на 15 минут (*или, может быть, здесь имеется в виду, что время на компьютере майнера установлено не слишком далеко в будущем?*)
3. Проверяется, что номер блока, его сложность, transaction root, uncle root and gas limit (различные низкоуровневые специфичные для Эфириум концепции) валидны.
4. Проверяется, что proof-of-work блока валиден.
5. Пусть `S[0]` обозначает `STATE_ROOT` предыдущего блока.
6. Пусть `TX` — список транзакций в блоке, а транзакций `n`. Для всех `0... n-1` положим `S[i+1] = APPLY(S[i],TX[i])` (состояние `i+1` есть состояние `i`, к которому применили транзакцию `i`; именно эта команда применяет все транзакции в блоке). Если при применении некоторых транзакций возникает ошибка, или если количество потреблённого газа при вычислении (соответствующих транзакциям) контрактов в блоке превысило `GASLIMIT`, вернуть ошибку.
7. Самая последняя транзакция в блоке — выплата майнеру награды за нахождение блока. Только после этого происходит приравнивание `S_FINAL = S[n]`.
8. Проверяется, совпадает ли `S_FINAL` со `STATE_ROOT`. Если да, блок валиден; в противном случае — нет.

Этот подход может показаться крайне неэффективным на первый взгляд, поскольку он предлагает в дополнение к списку транзакций хранить текущие состояния всех аккаунтов в каждом блоке, но в реальности эффективность должна быть сравнима с эффективностью Биткойна. И вот почему. Состояния хранятся в древовидной структуре, и после нахождения нового блока (с новыми транзакциями) лишь малая часть дерева должна быть изменена. Thus, in general, between two adjacent blocks the vast majority of the tree should be the same, and therefore the data can be stored once and referenced twice using pointers (ie. hashes of subtrees). Для этого используется специальный тип дерева — "дерево Патрисия", включающий (*или являющийся ей?*) модификацию дерева Мёркла, которая позволяет вставлять и удалять ноды (а не просто изменять). Скажем, наконец, о том, ради чего это затевалось: т.к. вся информация о состояниях содержится в последнем блоке, нет необходимости хранить всю историю блокчейна — если бы это удалось встроить в Биткойн, каждая полная нода занимала бы в 10-20 раз меньше места на жёстком диске.

## Приложения

Поверх Эфириум, по-видимому, возможны три типа приложений. Первая категория — финансовые приложения, предоставляющие пользователям мощные способы управления контрактами и заключения контрактов на свои активы. Примеры таких приложений — подвалюты, финансовые деривативы, контракты хеджирования, сберегательные кошельки, завещания, и даже некоторые виды контрактов трудоустройства. Вторая категория — полуфинансовые приложения, с участием также немонетарных материальных благ; идеальный пример здесь — самоисполняемые награды за решение важных вычислительных задач. Третья категория приложений — нефинансовые приложения, такие как онлайн-голосование и децентрализованное управление.

### Система жетонов 

Системы on-blockchain жетонов имеют самые разные приложения — от подвалют, представляющих активы (такие как доллары, золото) до акций компаний, жетонов, представляющих(?) умную собственность, безопасных неподделываемых купонов, и даже жетонов без привязки к какой-либо стоимости (выступающих в данном случае как плюсики на [форумах с кармой](http://habrahabr.ru)). Системы жетонов на удивление просто встраиваются в Эфириум. Дело в том, что и валюта, и система жетонов с необходимостью являются базой данных с одной операцией — отнять X единиц от состояния счёта A и прибавить X единиц к состоянию счёта B, со следующими пререквизитами: 1) A имеет как минимум X единиц перед началом транзакции 2) транзакция заявлена стороной A. Всё, что нужно для реализации системы жетонов — реализовать эту логику в контракте.

Простейший [Serpent](https://github.com/snordenstorm/wiki/wiki/%5BRussian%5D-Serpent-programming-language-operations)-код, осуществляющий систему жетонов, выглядит так:

```
from = msg.sender
to = msg.data[0]
value = msg.data[1]

if contract.storage[from] >= value:
    contract.storage[from] = contract.storage[from] - value
    contract.storage[to] = contract.storage[to] + value
```

Это буквально функция изменения состояния обычной банковской системы (уже описанная в этом документе чуть выше). Необходимо, конечно, в начало добавить ещё несколько строк кода, описывающих начальное распределение валюты и учесть ещё несколько моментов — в идеале, неплохо бы также добавить функцию, позволяющую другим контрактам запрашивать информацию о балансе произвольного адреса. Но это, в общем-то, и всё. Теоретически, основанные на Эфириум системы жетонов, ведущие себя как подвалюты, могут включать другую важную опцию, которой нет в метакойнах: возможность платить комиссии напрямую в такой подвалюте. The way this would be implemented is that the contract would maintain an ether balance with which it would refund ether used to pay fees to the sender, and it would refill this balance by collecting the internal currency units that it takes in fees and reselling them in a constant running auction. Users would thus need to "activate" their accounts with ether, but once the ether is there it would be reusable because the contract would refund it each time. Как это может быть реализовано: в контракт включается опция "возместить заранее указанную сумму, потраченную на комиссии". Пользователи, таким образом, должны будут "активировать" свои контракты некоторым количеством эфира, однако, как только эфир передан контракту, его можно будет использовать многократно, т.к. контракт будет возмещать его каждый раз. 

### Финансовые деривативы и валюты 

Финансовые деривативы — наиболее распространённое приложение смарт-контрактов, и одно из простейших с точки зрения написания кода. Главная сложность написания финансовых контрактов — в том, что большинство из них предполагает отсылку к курсу валюты (эфира), который должен браться из внешних источников; к примеру, крайне желанным приложением был бы смарт-контракт, хеджирующий риски волатильности эфира (или другой криптовалюты) по отношению к доллару США, но для работы такой контракт должен в режиме реального времени знать курс ETH/USD. Простейший способ реализовать это — через контракт на "поток информации" от условного NASDAQ, который обладает такими (ожидаемыми) свойствами: 
* этот внешний источник (условный NASDAQ) имеет право обновлять контракт при необходимости
* этот внешний источник (а с точки зрения Эфириум, это обычный контракт) предоставляет интерфейс, позволяющий другим контрактам переслать сообщение этому контракту и получить назад значение курса ETH/USD.

Теперь, когда у нас есть этот ключевой ингредиент, хеджирующий контракт мог бы выглядеть так:

1. Дождаться, пока А "вложит в контракт" 1000 единиц эфира.
2. Дождаться, пока B "вложит в контракт" 1000 единиц эфира.
3. Спросить у внешнего источника (контракта NASDAQ) курс ETH/USD, записать стоимость 1000 единиц эфира в долларах США в хранилище нашего контракта — пусть это $x.
4. Спустя 30 дней, разрешить A или B "реактивировать" контракт: переслать эфира текущей (т.е. уже при новом курсе ETH/USD) стоимостью $x стороне А, и остальное — стороне B.

Такой контракт может иметь значительный потенциал в криптокоммерции. Одной из главных проблем криптовалют остаётся их волатильность — при всей безопасности и всём удобстве работы с цифровыми активами вряд ли кому-то из физических лиц и продавцов могла бы понравиться перспектива потерять 23% своих сбережений за день. Up until now, the most commonly proposed solution has been issuer-backed assets; the idea is that an issuer creates a sub-currency in which they have the right to issue and revoke units, and provide one unit of the currency to anyone who provides them (offline) with one unit of a specified underlying asset (eg. gold, USD). The issuer then promises to provide one unit of the underlying asset to anyone who sends back one unit of the crypto-asset. This mechanism allows any non-cryptographic asset to be "uplifted" into a cryptographic asset, provided that the issuer can be trusted.

На практике же, однако, эмитентам доверять не приходится, и зачастую банковская инфраструктура недостаточно развита (слишком враждебна) к таким сервисам. Финансовые деривативы предоставляют альтернативу. Here, instead of a single issuer providing the funds to back up an asset, a decentralized market of speculators, betting that the price of a cryptographic reference asset (eg. ETH) will go up, plays that role. Unlike issuers, speculators have no option to default on their side of the bargain because the hedging contract holds their funds in escrow. Заметим, что этот подход всё же не полностью децентрализован, поскольку нуждается во внешнем источнике, поставляющем информацию о курсе ETH/USD. Но даже такой подход гораздо лучше подхода с эмитентами — он требует меньше инфраструктуры (в отличие от денег, эмиссия информации о курсе валюты не требует лицензий и является просто формой свободы слова) и уменьшает возможность мошенничества(?).

### Системы идентификации и репутации

Первая альтернативная криптовалюта, [Namecoin](http://namecoin.info/), пыталась использовать биткойн-подобный блокчейн для реализации системы регистрации имён, в которой пользователи могут регистрировать свои имена в публичной базе данных среди остальной информации. Наиболее обсуждаемый пример того, зачем это могло бы быть нужно — [DNS](http://ru.wikipedia.org/wiki/DNS)-система, отображающая доменные имена наподобие "kitten.bit" в IP-адрес. Другие возможные применения — email-аутентификация и, потенциально, продвинутые системы репутации. Вот пример простого контракта, который осуществляет Неймкойн-подобную систему регистрации имён в Эфириум:

```
if !contract.storage[tx.data[0]]:
    contract.storage[tx.data[0]] = tx.data[1]
```

The contract is very simple; all it is is a database inside the Ethereum network that can be added to, but not modified or removed from. Anyone can register a name with some value, and that registration then sticks forever. A more sophisticated name registration contract will also have a "function clause" allowing other contracts to query it, as well as a mechanism for the "owner" (ie. the first registerer) of a name to change the data or transfer ownership. Более того, поверх вполне можно добавить функционал репутаций (и предостережений при попытке взаимодействия с пользователем с низкой репутацией).

### Децентрализованное хранение файлов

В последние годы появилось немало стартапов, связанных с онлайн-хранением файлов. Наиболее известным таким стартапом является Dropbox, предлагающий своим пользователям загружать файлы в специальную папочку, которая после этого радостно синхронизируется с калифорнийскими серверами. Однако беглый взгляд на различные [существующие решения](http://online-storage-service-review.toptenreviews.com/) показывает, что в данный момент рынок хранения файлов сравнительно неэффективен; на 20—200-гигабайтовом уровне уже не предлагаются бесплатные аккаунты, но ещё не действуют скидки для предприятий, что приводит к стоимости месячного хранения файлов, сравнимого со стоимостью всего жёсткого диска. Контракты Эфириум могут породить настоящий бум в экосистеме децентрализованного хранения файлов, где отдельные пользователи будут зарабатывать небольшие суммы денег сдачей в аренду собственных жёстких дисков, а неиспользуемое сейчас дисковое пространство будет приводить лишь к снижению стоимости хранения файлов. 

Ключевым здесь является то, что мы назвали "децентрализованный Dropbox-контракт". Кратко опишем то, как он работает. 

1. Разбить информацию на блоки, каждый блок зашифровать для пущей приватности.
2. Построить дерево Мёркла из этих блоков.
3. 


У этого протокола есть такая важная фича: несмотря на то, что кажется, что владельцу файла приходится полагаться на большое количество случайных узлов, которые хранят его файл, риск может быть сведён практически до нуля предварительным разбиением на кусочки под названием "secret sharing". Контракты отслеживают то, хранят ли ноды нужные куски. Если по контракту доли выплачиваются, это и является доказательством того, что рассматриваемый узел действительно хранит часть файла.

### Децентрализованные автономные организации

Идея децентрализованных автономных организаций (ДАО) — это виртуальная организация, с каким-то количеством членов или держателей акций,. Члены могут коллективно решать, как организация должна распределять свои деньги. Методы распределения могут быть самые разные: от зарплат и премий до много более экзотических механизмов наподобие внутренней валюты. Звучит похоже на обычные организации, но правоприменение здесь происходит только посредством блокчейн-технологии. К настоящему моменту дискуссии вокруг ДАО велись вокруг "капиталистической" модели "децентрализованной автономной корпорации" (ДАК) с получающими дивиденды владельцами акций и торгующимися акциями; альтернатива, которую, возможно, следовало бы назвать "децентрализованной автономное сообщество", такова: все члены имеют одинаковое право голоса и 67% членов должны согласиться с добавлением/исключением члена для вынесения решения. Требование того, чтобы один человек имел только одно членство.

Обсудим то, как бы мог выглядеть код децентрализованной автономной организации. Первое, что приходит в голову — код, умеющий самоизменяться, если 2/3 членов дали согласие на некоторое изменение. Although code is theoretically immutable, one can easily get around this and have de-facto mutability by having chunks of the code in separate contracts, and having the address of which contracts to call stored in the modifiable storage. При простой реализации ДАО-контракта будет три типа транзакций, отличающихся информацией транзакции:

* `[0,i,K,V]` to register a proposal with index i to change the address at storage index K to value V

* `[0,i]` to register a vote in favor of proposal i

* `[2,i]` to finalize proposal i if enough votes have been made

Такой контракт будет иметь пункт для каждой. 

Альтернативная модель — децентрализованная корпорация, где любой аккаунт может иметь ноль или больше акций, и 2/3 акций необходимы для вынесения решения. Полный "позвоночник" организации включал бы в себя функционал управления активами, возможность сделать предложение покупки/продажи акций, и возможность принимать предложения (предпочтительно with an order-matching mechanism inside the contract). Delegation would also exist Liquid Democracy-style, generalizing the concept of a "board of directors".

### Дальнейшие приложения

**1. Сберегательные кошельки.** Предположим, Алиса хочет сохранить свои сбережения, но опасается того, что потеряет или кто-либо украдёт её приватный ключ. Она заключает контракт с Бобом (который заменяет банк), обеспеченный эфиром Алисы. Контракт может иметь такой вид:

   * В одиночку Алиса может забрать не более 1% средств в день.

   * В одиночку Боб может забрать не более 1% средств в день, но Алиса имеет право наложить вето на этот пункт.

   * Алиса и Боб по договорённости могут забрать любую часть средств. 

Обычно 1% в день — это более чем достаточно для Алисы, и если Алиса захочет забрать больше, по договорённости с Бобом она сможет воспользоваться третьим пунктом. Если приватный ключ Алисы будет украден, она обратится к Бобу за перемещением средств на новый контракт. Если она потеряет свой приватный ключ, Боб получит все средства в конце концов. Если Боб окажется подозрительным лицом, она сможет отменить пункт, позволяющий ему забирать средства.

**2. Страхование урожая.** Каждый может создать контракт по управлению финансовыми деривативами, но использующий сведения о погоде, а не о цене актива, в качестве исходных данных. Если краснодарский фермер покупает дериватив, выплаты по которому производятся обратно пропорционально осадкам в его регионе, тогда и в случае засухи фермер не будет страдать, и в случае достаточного количества дождей, очевидно, тоже.

**3. Децентрализованный поток информации.** 

**4. Смарт-эскроу** с мультиподписью. Биткойн позволяет заключать транзакционные контракты с мультиподписью, где, к примеру, три из пяти ключей могут расходовать средства. Эфириум позволяет более замысловатые контракты — для примера, "4 из 5 могут потратить все средства, 3 из 5 могут тратить до 10% в день, 2 из 5 могут тратить до 0.5% в день". В дополнение к сказанному, мультиподпись Эфириума асинхронна — две стороны могут поставить свою подпись в разное время, и последняя из них автоматически произведёт транзакцию.

**5. Облачные вычисления.**

**6. Peer-to-peer азартные игры.** Любое количество протоколов peer-to-peer азартных игр, such as Frank Stajano and Richard Clayton's Cyberdice, может быть включено в блокчейн Эфириума. Простейший такой протокол — контракт на разницу с хэшем следующего блока, и могут быть созданы более продвинутые протоколы сервисов азартных игр с практически нулевыми комиссиями, при этом в таких азартных играх нет никакой возможности жульничества.

**7. Рынки предсказаний.**

**8. Децентрализованные рынки** на основе блокчейна, в основании которых лежат описанные нами в соответствующем разделе системы идентификации и репутации.

## Размышления и разное

### Реализация modified GHOST

Протокол [GHOST](http://www.cs.huji.ac.il/~avivz/pubs/13/btc_scalability_full.pdf) ("Greedy Heavist Observed Subtree") — инновация, впервые введённая Йонатан Сомполински и Авив Зохар в декабре 2013. Мотивация GHOST: блокчейны с быстрым временем подтверждения транзакции в данный момент страдают от недостаточной безопасности ввиду большого количества "прокисших" блоков. Поясним, что имеется в виду. Так как блокам нужно сколько-то времени для того, чтобы распространиться по сети, если майнер А находит блок, а затем майнер B находит другой блок с таким же порядковым номером до того, как к нему распространится информация о находке майнера A, блок майнера B остаётся ненужным, не войдёт в блокчейн, и вычисления майнера B никак не помогут сообществу. Такие блоки мы и будем называть "прокисшими" (*англ. термин* - stale). Этот эффект заметно усиливает тенденцию к централизации: если майнер A — это майнинг-пул, суммарная мощность которого составляет 30% мощности всей сети, а у майнера (майнинг-пула) B эта цифра составляет 10% мощности всей сети, A будет иметь риск найти "прокисший" блок 70% времени (т.к. лишь в 30% случаев A будет находить последний блок), а B, соответственно, будет иметь риск найти "ненужный" блок 90% времени. Таким образом, если интервал между блоками достаточно короткий, "прокисших" блоков будет много и они будут заметно влиять на майнинг, и майнер B в нашем примере будет многократно проигрывать майнеру A даже не только за счёт меньшей мощности, но также и из-за того, что будет находить гораздо больше "прокисших" блоков. Майнеры будут переходить на крупные пулы, и всё это приведёт к тому, что блокчейны с малым временем генерации блока будут майниться на 1-2 крупных пулах, которые будут полностью контролировать майнинг, после чего [атака 51%](линк) неизбежна.

Сомполински и Зохар описали GHOST, который решает первую из этих проблем включением "прокисших" блоков в вычисление, определяющее самый длинный (с точки зрения количества proof-of-work) отросток блокчейна. Для того, чтобы решить проблему централизации, мы выходим за рамки GHOST-протокола и вводим выплаты за "прокисшие" блоки: "прокисший" блок получает 87.5% от того, что бы получил, если б был принят в блокчейн, 

Это было сделано по нескольким причинам. Во-первых, полная версия протокола GHOST сильно бы усложнила вычисление того, какие дяди данного блока валидны. Во-вторых, полная версия GHOST при предлагаемой Эфириум системе компенсации за "прокисшие" блоки приводит к отсутствию стимула майнить главную цепь блокчейна; как известно ...., а не цепь возможного злоумышленника. Кроме того, одноуровневый GHOST приносит 80% пользы от полного GHOST-протокола, и процент прокисших блоков в нём при block time (среднего времени нахождения нового блока) 40 секунд таков же, как у Лайткойна (как известно, block time Лайткойна — 2.5 минуты). Однако мы будем чуть более консервативны при выборе block time и положим его равным 60 секунд (как у Праймкойна), поскольку верификация некоторых блоков занимает чуть больше обычного.

### Комиссии

Поскольку любую транзакцию, помещённую отправителем в блокчейн, кто-то должен добавить в блок и проверить, должен быть некоторый регуляторный механизм (комиссии) во избежание злоупотреблений. Подход, используемый в Биткойн — комиссия устанавливается отправителем и может быть какой угодно, в том числе равной нулю (но когда награды за нахождение блока станут крайне низкими, основную долю заработка майнера будут составлять именно комиссии, и транзакции с меньшими комиссиями будут включаться в блокчейн в последнюю очередь, что приведёт к тому, что какие-то комиссии люди всё-таки будут платить, устанавливая тем самым динамическую сумму предполагаемой комиссии). Это свойство Биткойн-протокола вызвало широкое одобрение Биткойн-сообщества как "рыночное", позволяющее спросу и предложению на услуги майнеров определять цену. Проблема такого подхода в том, что проведение транзакций не слишком похоже на рынок, пусть это и привлекательно — представлять проведение транзакций как рынок майнинг-услуг. 

В реальности же каждая транзакция, включённая майнером в блок, должна быть проведена каждым узлом сети, так что практически вся часть "стоимости проведения транзакции" осуществляется людьми, не получающими от неё никакой прибыли. Практически бесплатная себестоимость [порождает злоупотребления](http://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%B3%D0%B5%D0%B4%D0%B8%D1%8F_%D0%BE%D0%B1%D1%89%D0%B8%D0%BD).

Однако этот недостаток рыночного механизма при некотором упрощении магически исчезает. Аргумент тут такой. Предположим, что:

1. Пусть транзакция состоит из `k` операций и предлагает комиссию в `kR` майнеру, который включит её в блокчейн, где `R` задаётся отправителем, а `k` и `R` более-менее известны майнеру заранее.
2. Себестоимость проведения операций для каждого нода равна `C` (т.е. все ноды одинаково эффективны)
3. Обозначим число майнящих нод за `N`, и пусть вычислительные мощности всех одинаковы (т.е. равны `1/N` от полного хэшрэйта сети).
4. Нет полных нод, которые не заняты в майнинге.

Майнер захочет провести только те транзакции, комиссия за которые превысит себестоимость проведения транзакций. Таким образом, ожидаемая награда здесь — `kR/N`, т.к. вероятность нахождения блока с рассматриваемой транзакцией (да какого угодно блока) в нашей модели равна `1/N`. (Окей, более точно — матожидание награды равно `kR/N`.) Себестоимость же проведения транзакции равна просто `kC`. Таким образом, майнеры будут включать такие транзакции в блок, для которых `kR/N > kC`, или `R > NC`. Ещё раз подчеркнём, что `R` — устанавливаемая отправителем комиссия за каждую операцию транзакции, а `NC` — себестоимость проведения операции для всей сети. 

Однако наша модель всё же не очень похожа на реальность. И вот почему:

1. Себестоимость проведения транзакций для майнера, нашедшего блок и включившего её в него, всё-таки выше, чем себестоимость для всех остальных нод, которые занимаются её верификацией. Дело в том, что время, необходимое на верификацию, замедляет распространение блока в сети, что увеличивает вероятность того, что блок станет "прокисшим" и не принесёт никакой прибыли.
2. Существуют полные ноды, которые не занимаются майнингом. 
3. Вычислительные мощности майнеров распределены крайне неравномерно, и тенденция здесь, увы, в сторону дальнейшего увеличения "коэффициента Джини".
4. Спекулянты, боящиеся конкуренции политики и разного рода фанатики, стремясь нанести вред сети, вполне могут создать замысловатые контракты, себестоимость которых для них самих будет гораздо ниже, чем себестоимость для верифицирующих (=почти всех остальных) нод.

По причине (1) майнерам выгоднее включать в блок поменьше транзакций, причина (2) увеличивает `NC`; так что эти два эффекта хотя бы частично компенсируют друг друга. 
Пункты (3) и (4) являются известной проблемой; для того, чтобы пофиксить её, мы вводим плавающий лимит: ни один блок не может иметь больше операций, чем `BLK_LIMIT_FACTOR` умножить на долгосрочное экспоненциально изменяющееся среднее значение. Более детально, `blk.oplimit = floor((blk.parent.oplimit * (EMAFACTOR - 1) + floor(parent.opcount * BLK_LIMIT_FACTOR)) / EMA_FACTOR)`. `BLK_LIMIT_FACTOR` и `EMA_FACTOR` — константы, которые пока что предлагается положить равными 65536 и 1.5 соответственно, но эти значения, скорее всего, изменятся после более глубокого анализа.

### Вычисление и Тьюринг-полнота

Крайне важно, что ВМЭ Тьюринг-полна; это означает, что ВМЭ-код может реализовать любое мыслимое вычисление, включая бесконечные циклы. ВМЭ-код допускает два способа написать бесконечный цикл. Во-первых, можно использовать инструкцию `JUMP` (или `JUMPI`, которая выполняет `JUMP` при выполнении некоторого условия), которая позволяет вернуться в одну из предыдущих строк кода. Во-вторых, контракты могут обращаться к другим контрактам, что потенциально может привести к рекурсии. Это, естественно, проблема: могут ли недобросовестные пользователи выключить майнеров и полные ноды, вводя их в бесконечный цикл? В computer science это известно как [проблема остановки](http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0_%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8): Тьюринг в своё время доказал, что не существует общего алгоритма, который позволял бы определить, закончится ли когда-либо выполнение той или иной программы. 

Как описано в разделе "Изменение состояния", наше решение — в том, чтобы задать максимально допустимое число шагов в вычислении, и если в вычислении больше шагов, вычисление прерывается, произведённые изменения откатываются, но комиссии за него автором контракта уплачиваются. С сообщениями та же история. Чтобы пояснить причины такого решения, рассмотрим следующие примеры:

* Злоумышленник создаёт контракт с бесконечным циклом, и затем пересылает транзакцию, активирующую этот контракт, майнеру. Майнер, проводя транзакцию, попадает в бесконечный цикл, и в какой-то момент его газ заканчивается. Выполнение контракта на этом останавливается, но транзакция, активировавшая этот контракт, остаётся валидной и майнер радостно взимает со злоумышленника комиссию за каждый вычислительный шаг.

* Злоумышленник создаёт цикл такой длины, чтобы за время, которое майнер будет вычислять его до конца, было найдено ещё несколько блоков, и майнер не мог включить транзакцию в следующий блок, чтобы потребовать комиссию. Однако злоумышленник должен будет задать значение переменной `STARTGAS`, ограничивающей количество вычислительных шагов, так что майнер заранее будет знать, какой контракт может содержать сумасшедшее количество вычислительных шагов.

* Злоумышленник видит контракт наподобие `send(A,contract.storage[A]); contract.storage[A] = 0`, и пересылает транзакцию с количеством газа, достаточным только для выполнения первого шага, но не для второго (в данном примере — забирая деньги, но не давая балансу уменьшиться). Автор контракта не должен волноваться о возможности таких атак, ведь если вычисление прерывается, произведённые изменения откатываются.

* Финансовый контракт берёт среднее от, скажем, девяти частных источников информации (для минимизации риска). Злоумышленник берёт один из этих потоков (который модифицируемый с помощью variable-address-call mechanism described in the section on DAOs), and converts it to run an infinite loop, thereby attempting to force any attempts to claim funds from the financial contract to run out of gas. Для защиты от подобного можно просто указать gas limit сообщения.

Альтернатива Тьюринг-полноты языка — Тьюринг-неполнота, где нет инструкций `JUMP` и `JUMPI`, и только одна копия каждого контракта может существовать в стеке в каждый момент времени. В такой ситуации описанная система комиссий и паранойя по поводу возможности рекурсии теряют актуальность, поскольку в отсутствие возможности устроить бесконечный цикл стоимость выполнения контракта будет ограничена сверху его размером. Дополнительно, Тьюринг-неполнота — не то чтобы такое уж сильное ограничение; из всех рассмотренных нами контрактов пока что только один содержал "петлю" (инструкцию типа `JUMP`), и даже этой петли можно было избежать (хорошо звучит), 26 раз повторив одну строчку. Возникает вопрос — есть ли какая-то серьёзная необходимость вводить в Эфириум Тьюринг-полный язык, если он причиняет нам столько проблем? Оказывается, что Тьюринг-неполнота языка не приводит к решению всех этих проблем. Рассмотрим такой контракт:

```
C0: call(C1); call(C1);
C1: call(C2); call(C2);
C2: call(C3); call(C3);
...
C49: call(C50); call(C50);
C50: (run one step of a program and record the change in storage)
```

Перешлём кому-нибудь транзакцию с таким контрактом. Тогда для 51 транзакции наш контракт занимает 2<sup>50</sup> вычислительных шагов. Майнеры могли бы пресекать такие логические бомбы, устанавливая максимально допустимое число вычислительных шагов для каждого контракта и не останавливая счётчик шагов в том числе когда в теле одного контракта выполняется другой контракт. Но что, по-видимому, майнерам всё-таки придётся запретить — контракты, не вызывающие, а создающие другие контракты. Другая проблема здесь в том, что поле "адресат сообщения" — переменная, так что в общем случае, видимо, нельзя предсказать, какие другие контракты будет вызывать данный контракт. Так что в итоге имеем нечто поистине удивительное: Тьюринг-полный язык прост в использовании; отсутствие Тьюринг-полноты языка не приводит к тому, что возможность атаки бесконечным циклом на сеть отпадает сама; механизм защиты от бесконечного цикла в случае Тьюринг-неполного языка такой же, как в случае Тьюринг-полного. Поэтому почему бы не позволить себе радость пользоваться Тьюринг-полным языком? (:

### Валюта и выпуск

Сеть Эфириум включает в себя свою собственную встроенную валюту *эфир*, введённую с двумя целями: 1) предоставить по-настоящему ликвидную валюту для обмена цифровыми активами 2) предоставить механизм оплаты стоимости транзакций. Для удобства и во избежание будущих споров и дискуссий (как это сейчас происходит с Биткойном при обсуждениях названий для миллибиткойна, микробиткойна и мельчайшей частички Биткойна) номиналы валют предлагается обозначить:

* 1: wei
* 10<sup>3</sup>: lovelace
* 10<sup>6</sup>: babbage
* 10<sup>9</sup>: shannon
* 10<sup>12</sup>: szabo
* 10<sup>15</sup>: finney
* 10<sup>18</sup>: ether

Это расширенная версия долларов/центов, рублей/копеек, биткойн/сатоши. Мы ожидаем, что "ether" будет использоваться для обычных транзакций, "finney" — для микротранзакций, "szabo" и "wei" — для технических дискуссий о протоколе; оставшиеся номиналы могут понадобиться позже и не должны быть пока что включены в стандартный Эфириум-клиент.

Модель выпуска может быть следующей:

* Эфир будет выставлен на продажу по цене 1000-2000 единиц эфира за 1 BTC; на вырученные деньги будет профинансирована проделанная и дальнейшая разработка Эфириума, как это имело место с Мастеркойн и NXT. Для первых покупателей будут действовать скидки. Биткойны, полученные с продажи, будут полностью использоваться для выплаты зарплат и премий разработчикам, а также инвестированы в различные коммерческие и некоммерческие проекты в экосистеме Эфириум.

* 30% от полного количества проданного эфира будет оставлено организации, чтобы поощрить ранних участников, выплатить ETH-расходы перед первым блоком и в качестве долгосрочного резерва. Это количество распределено в соответствии с законом экспоненциального затухания; каждый месяц до 5.6% оставшегося фонда может быть распределено между разработчиками и другими лицами, принимавшими участие в развитии проекта; распределение этих средств начнётся в декабре.

* 30% от полного количества проданного эфира будет добываться майнерами в год, и так будет всегда.

Group | At launch | After 1 year | After 5 years
------------ | ------------- | ------------- | -------------
Currency units | 1.3X | 1.6X | 2.8X
Purchasers | 76.9% | 62.5% | 35.7%
Reserve spent pre-sale | 5.77% | 4.69% | 2.68%
Reserve used post-sale | 17.3% | 14.1% | 8.04%
Miners | 0% | 23.1% | 53.6%

![](https://camo.githubusercontent.com/74e77c17b59abcbb24fa37721a18daf39e3ee90b/68747470733a2f2f7777772e657468657265756d2e6f72672f67685f77696b692f696e666c6174696f6e2e737667)

*В точности как и в системе Биткойн, несмотря на линейный во времени выпуск валюты, показатель роста количества валюты со временем стремится к нулю*

Можно выделить две главных особенности нашей модели выпуска: 

1. наличие фонда, принадлежащего Эфириум-организации
2. существование вечно растущего количества денег (в отличие от ограниченного количества в Биткойн).

Как нам кажется, фонд необходим, и вот почему. Если его не создать (при этом уменьшив эмиссию до 0.231x для сохранения того же процента инфляции), полное количество эфира будет на 23% меньше, и каждая единица будет обладать на 30% большей стоимостью. Следовательно, при продаже будет раскуплено на 30% больше эфира, так что каждая единица станет иметь абсолютно ту же стоимость, что и раньше. Организация при этом получит в 1.3 больше BTC, нежели при модели с фондом. Таким образом, ситуация с отсутствием фонда *приводит в точности к тому же*, что и ситуация с фондом, с одной лишь разницей: организация получит только BTC, и будет слегка менее заинтересована в дальнейшем развитии валюты.

"Вечный" линейный рост валюты уменьшает риск инстамайна — сверхприбылей первых майнеров, и больших (по отношению к последующему поколению) прибылей текущих майнеров. Такая модель даёт последующим поколениям майнеров те же возможности, что есть у живущих сейчас — что, наверное, справедливо. В то же время, поскольку процент, на который растёт количество валюты (=процент инфляции), со временем стремится к нулю, резон хранить в ней свои сбережения будет. Также поскольку полное число монет, доступных владельцам, будет уменьшаться по невнимательности (выброшенный жёсткий диск, забытый пароль от зашифрованного кошелька, ..), и если предположить, что в среднем теряется 1% монет в год, количество монет в обращении стабилизируется на значении, равном годовой эмиссии, поделённой на процент потерь (к примеру, если теряется 1% всех монет в год, )

### Централизация майнинга

Алгоритм майнинга Биткойна устроен так: майнеры вычисляют SHA-256 на несколько разных версиях заголовка блока миллионы и миллионы раз, пока кто-нибудь не обнаружит хэш меньше, чем нужно (сейчас это число равно 2<sup>192</sup>). Однако этот алгоритм майнинга уязвим по отношению к двум формам централизации. Во-первых, специализированные устройства для майнинга — АСИКи (ASIC: application-specific integrated circuits) имеют многократно бóльшие вычислительные мощности, нежели остальные. Таким образом, майнинг биткойнов более не является абсолютно децентрализованной и равноправной гонкой, и требует миллионов долларов инвестиций в спецоборудование, если заниматься этим серьёзно. Во-вторых, большинство биткойн-майнеров не производят валидацию блока; они надеются на свои майнинг-пулы, которые централизованы. Возможно, дело обстоит даже хуже: на момент написания этих строк три самых крупных майнинг-пула косвенно контролируют примерно 50% вычислительных мощностей ([всё уже гораздо хуже](http://habrahabr.ru/post/226567/), мощность пула ghash.io уже несколько раз превысила 51% мощности сети — *прим. перев.*), что, правда, смягчается тем фактом, что майнеры могут переключиться на другие майнинг-пулы если пул или несколько пулов попробуют предпринять атаку 51%. 

На данный момент мы собираемся решить эту проблему с помощью алгоритма, при котором майнеры fetch random data from the state, compute some randomly selected transactions from the last N blocks in the blockchain, and return the hash of the result. У этого есть два важных плюса. Во-первых, контракты Эфириума могут включать в себя вычисления любого сорта, так что Эфириум-АСИК должен с необходимостью быть АСИКом для любого вида вычислений — т.е. более мощным процессором. Во-вторых, для майнинга необходим доступ ко всему блокчейну, что приводит к необходимости для майнеров хранить весь блокчейн и быть способными как минимум проверить каждую транзакцию. Это делает ненужным существование майнинг-пулов в их современном понимании; хотя они могут продолжать работу, пиринговые пулы, которые по определению децентрализованы, способны выполнять задачу обычных пулов ничем не хуже.

Эта модель не оттестирована, и сложности с использованием контрактов как майнинг-алгоритмов действительно могут быть. Однако одна интересная особенность этого алгоритма заключается в том, что она разрешает кому угодно "отравить колодец", вводя такие контрактов в блокчейн, которые способны сделать непригодными для их вычисления тот или иной АСИК. Производители АСИКов могли бы использовать эту возможность для атаки друг друга. Таким образом, решение, которое мы разрабатываем — с необходимостью адаптивное экономико-социальное, нежели сугубо техническое.

### Масштабируемость

Как и Биткойн, Эфириум страдает от того недостатка, что каждая транзакция должна быть проведена каждым узлом сети. Текущий размер биткойн-блокчейна — 15 Гб, и он растёт примерно на 1 Мб в час. Если бы сеть Биткойн производила 2000 транзакций в секунду, как Visa, то блокчейн бы рос на 1 Мб каждые три секунды (1 Гб в час, 8 Тб в год). Эфириум, по-видимому, будет испытывать те же проблемы, отягощённые наличием огромного количества приложений, действующих поверх блокчейна Эфириума, но на самом деле не всё так плохо, потому что в Эфириум полным нодам не нужно хранить историю блокчейна, достаточно лишь помнить текущее состояние (баланс и состояние контрактов(*мб что-то ещё?*)) каждого из пользователей.

Проблема большого размера блокчейна, конечно, в риске централизации. Если размер блокчейна возрастает до 100 Тб, лишь малое количество бизнесов будут держателями полных нод, а простые пользователи будут держать "лёгкие" УВП-ноды. В такой ситуации владельцы полных нод могли бы вступить в сговор (например, изменить выплату за найденный блок, выдать самим себе BTC (*полностью понять, что они могли бы сделать и чего не могли*)). "Лёгкие" ноды не смогут обнаружить такой вид мошенничества немедленно. Конечно, хотя бы один владелец полной ноды скорее всего честен, и спустя несколько часов информация о мошенничестве утечёт через условный [Реддит](http://www.reddit.com/r/CryptoCurrency/), но это будет слишком поздно: простые пользователи должны будут организовывать свою работу по занесению конкретных блоков в чёрные списки, массивную и, вероятно, невыполнимую работу по координации такой же сложности, как отбить атаку 51%. В ситуации с биткойном это проблема, но есть [модификация блокчейна](http://sourceforge.net/p/bitcoin/mailman/message/31709140/), предложенная Петером Тоддом, которая смягчает эту сложность.

В ближайшем будущем Эфириум собирается использовать две дополнительные стратегии, чтобы преодолеть эту проблему. Во-первых, из-за того, что майнинг-алгоритмы основаны на блокчейне, каждый майнер должен будет держать полную ноду => количество полных нод будет не меньше, чем количество майнеров. Во-вторых, что более важно, мы планируем включить промежуточное state tree root в блокчейн после проведения каждой транзакции. Даже если валидация блоков недостаточно децентрализована, пока хотя бы один честный узел занимается верификацией, проблемы централизации можно избежать с помощью верификационного протокола. Если майнер публикует невалидный блок, этот блок либо имеет неправильный формат, либо состояние `S[n]` некорректно. Поскольку начальное состояние — `S[0]` — корректно, существует какое-то первое некорректное состояние `S[i]` (при корректном `S[i-1]`). Верифицирующий узел предоставит индекс `i` вместе с proof-of-invalidity, состоящим из подмножеств узлов дерева Патрисия, пытающихся произвести `APPLY(S[i-1],TX[i]) -> S[i]`. Узлы смогут использовать эти части дерева Патрисия для выполнения нужного куска вычисления, и убедиться, что получившееся `S[i]` не совпадает с предъявленным майнером. 

Возможна более замысловатая атака: недобросовестные майнеры могут публиковать неполные блоки, так что полной информации, которая могла бы показать валидность/невалидность блока, попросту не существует. Решением здесь является challenge-response протокол: verification nodes issue "challenges" in the form of target transaction indices, and upon receiving a node a light node treats the block as untrusted until another node, whether the miner or another verifier, provides a subset of Patricia nodes as a proof of validity.

## Заключение

Эфириум-протокол изначально начинался как улучшенная версия криптовалюты, предоставляющая дополнительные возможности, такие как эскроу на блокчейне, withdrawal limits, финансовые контракты, рынки азартных игр и подобное посредством высокоуровневого языка программирования. Эфириум-протокол не поддерживает какое-либо из "приложений" напрямую, но существование Тьюринг-полного языка программирования означает, что контракты могут быть составлены совершенно произвольно. Что особенно вдохновляет, Эфириум — это гораздо больше, чем криптовалюта. Протоколы децентрализованного хранения файлов, децентрализованных вычислений и децентрализованных рынков предсказаний, а также десятки других концепций, имеют потенциал существенно увеличить эффективность IT-индустрии. Разумеется, есть и значительное количество приложений, не имеющих никакого отношения к деньгам.

Концепция произвольности функции изменения состояния, включённая в Эфириум-протокол, предоставляет платформу с уникальным потенциалом; в отличие от узкоспециализированных проектов — скажем, в области шифрования информации, азартных игр или финансов — Эфириум имеет крайне широкую специализацию по архитектуре, и мы верим, что Эфириум прекрасно подходит в качестве базовой платформы для финансовых и нефинансовых протоколов ближайших лет.

## Заметки и дальнейшее чтение

### Заметки

1. A sophisticated reader may notice that in fact a Bitcoin address is the hash of the elliptic curve public key, and not the public key itself. However, it is in fact perfectly legitimate cryptographic terminology to refer to the pubkey hash as a public key itself. This is because Bitcoin's cryptography can be considered to be a custom digital signature algorithm, where the public key consists of the hash of the ECC pubkey, the signature consists of the ECC pubkey concatenated with the ECC signature, and the verification algorithm involves checking the ECC pubkey in the signature against the ECC pubkey hash provided as a public key and then verifying the ECC signature against the ECC pubkey.

2. Technically, the median of the 11 previous blocks.

3. С точки зрения системы, и 2, и "CHARLIE" — числа; with the latter being in big-endian base 256 representation. Числа лежат в интервале от 0 до 2<sup>256</sup>-1 (концы включаются).

### Дальнейшее чтение

1. Внутренняя стоимость: http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/

2. Умная собственность: https://en.bitcoin.it/wiki/Smart_Property, http://bitnovosti.com/2014/06/10/ponyatie-umnoi-sobstvennosti/

3. Смарт-контракты: https://en.bitcoin.it/wiki/Contracts

4. B-money: http://www.weidai.com/bmoney.txt

5. Reusable proofs of work: http://www.finney.org/~hal/rpow/

6. Secure property titles with owner authority: http://szabo.best.vwh.net/securetitle.html

7. Манифест Биткойн: http://bitcoin.org/bitcoin.pdf

8. Namecoin: https://namecoin.org/

9. Zooko's triangle: http://en.wikipedia.org/wiki/Zooko's_triangle

10. Манифест "цветных монет": https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit

11. Манифест Мастеркойн: https://github.com/mastercoin-MSC/spec

12. Децентрализованные автономные корпорации, Bitcoin Magazine: http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/

13. Упрощённая верификация платежей: https://en.bitcoin.it/wiki/Scalability#Simplifiedpaymentverification

14. Деревья Мёркла: http://en.wikipedia.org/wiki/Merkle_tree

15. Деревья Патрисия: http://en.wikipedia.org/wiki/Patricia_tree

16. GHOST: http://www.cs.huji.ac.il/~avivz/pubs/13/btc_scalability_full.pdf

17. StorJ and Autonomous Agents, Jeff Garzik: http://garzikrants.blogspot.ca/2013/01/storj-and-bitcoin-autonomous-agents.html

18. Mike Hearn on Smart Property at Turing Festival: http://www.youtube.com/watch?v=Pu4PAMFPo5Y

19. Ethereum RLP: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP

20. Ethereum Merkle Patricia trees: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-Patricia-Tree

21. Peter Todd on Merkle sum trees: http://sourceforge.net/p/bitcoin/mailman/message/31709140/